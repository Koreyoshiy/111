            swap_in(mm, addr, &page);
            page_insert(mm->pgdir, page, addr, perm); 
            swap_map_swappable(mm, addr, page, 1); 
            page->pra_vaddr = addr;

fork_out:
    return ret;

bad_fork_cleanup_kstack:
    put_kstack(proc);
bad_fork_cleanup_proc:
    kfree(proc);
    goto fork_out;


// Exercise 1: alloc_proc
static struct proc_struct *
alloc_proc(void) {
    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
    if (proc != NULL) {
        proc->state = PROC_UNINIT;                      // Process state
        proc->pid = -1;                                 // Process ID
        proc->runs = 0;                                 // The running times of Process
        proc->kstack = 0;                               // Process kernel stack
        proc->need_resched = false;                     // Bool value: need to be rescheduled to release CPU?
        proc->parent = NULL;                            // The parent process
        proc->mm = NULL;                                // Process's memory management field
        memset(&(proc->context), 0, sizeof(struct context)); // Switch here to run process
        proc->tf = NULL;                                // Trap frame for current interrupt
        proc->cr3 = boot_cr3;                           // CR3 register: the base addr of Page Directroy Table(PDT)
        proc->flags = 0;                                // Process flag
        memset(proc->name, 0, PROC_NAME_LEN);           // Process name
    }
    return proc;
}

// Exercise 2: do_fork
int
do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {
    int ret = -E_NO_FREE_PROC;
    struct proc_struct *proc;
    if (nr_process >= MAX_PROCESS) {
        goto fork_out;
    }
    ret = -E_NO_MEM;

    // 1. call alloc_proc to allocate a proc_struct
    proc = alloc_proc();
    if (proc == NULL) {
        goto fork_out;
    }

    // 2. call setup_kstack to allocate a kernel stack for child process
    if (setup_kstack(proc) != 0) {
        goto bad_fork_cleanup_proc;
    }

    // 3. call copy_mm to dup OR share mm according clone_flag
    if (copy_mm(clone_flags, proc) != 0) {
        goto bad_fork_cleanup_kstack;
    }

    // 4. call copy_thread to setup tf & context in proc_struct
    copy_thread(proc, stack, tf);

    // 5. insert proc_struct into hash_list && proc_list
    hash_proc(proc);
    list_add(&proc_list, &(proc->list_link));
    nr_process ++;

    // 6. call wakeup_proc to make the new child process RUNNABLE
    wakeup_proc(proc);

    // 7. set ret value using child proc's pid
    ret = proc->pid;

    goto fork_out;

bad_fork_cleanup_kstack:
    put_kstack(proc);
bad_fork_cleanup_proc:
    kfree(proc);
fork_out:
    return ret;
}

// Exercise 3: proc_run
void
proc_run(struct proc_struct *proc) {
    if (proc != current) {
        bool intr_flag;
        local_intr_save(intr_flag); // Disable interrupts
        {
            current = proc;
            load_esp0(proc->kstack + KSTACKSIZE);
            lcr3(PADDR(proc->cr3)); // Modify the value of CR3 register
            switch_to(&(current->context)); // Context switching between two processes
        }
        local_intr_restore(intr_flag); // Enable Interrupts
    }
}

+ cc kern/init/entry.S
+ cc kern/init/init.c
kern/init/init.c: In function 'grade_backtrace1':
kern/init/init.c:58:28: warning: cast from pointer to integer of different size [-Wpointer-to-int-cast]
     grade_backtrace2(arg0, (int)&arg0, arg1, (int)&arg1);
                            ^
kern/init/init.c:58:46: warning: cast from pointer to integer of different size [-Wpointer-to-int-cast]
     grade_backtrace2(arg0, (int)&arg0, arg1, (int)&arg1);
                                              ^
kern/init/init.c: In function 'grade_backtrace':
kern/init/init.c:68:25: warning: cast from pointer to integer of different size [-Wpointer-to-int-cast]
     grade_backtrace0(0, (int)kern_init, 0xffff0000);
                         ^
+ cc kern/libs/readline.c
+ cc kern/libs/stdio.c
+ cc kern/debug/kdebug.c
+ cc kern/debug/kmonitor.c
+ cc kern/debug/panic.c
+ cc kern/driver/clock.c
+ cc kern/driver/console.c
+ cc kern/driver/ide.c
+ cc kern/driver/intr.c
+ cc kern/driver/picirq.c
+ cc kern/trap/trap.c
+ cc kern/trap/trapentry.S
+ cc kern/mm/default_pmm.c
+ cc kern/mm/kmalloc.c
kern/mm/kmalloc.c: In function '__slob_free_pages':
kern/mm/kmalloc.c:92:23: warning: passing argument 1 of 'kva2page' makes pointer from integer without a cast [-Wint-conversion]
   free_pages(kva2page(kva), 1 << order);
                       ^~~
In file included from kern/mm/kmalloc.c:7:
kern/mm/pmm.h:109:16: note: expected 'void *' but argument is of type 'long unsigned int'
 kva2page(void *kva) {
          ~~~~~~^~~
+ cc kern/mm/pmm.c
+ cc kern/mm/swap.c
+ cc kern/mm/swap_fifo.c
+ cc kern/mm/vmm.c
+ cc kern/fs/swapfs.c
+ cc kern/process/entry.S
+ cc kern/process/proc.c
kern/process/proc.c: In function 'alloc_proc':
kern/process/proc.c:109:30: error: 'false' undeclared (first use in this function)
         proc->need_resched = false;                     // Bool value: need to be rescheduled to release CPU?
                              ^~~~~
kern/process/proc.c:109:30: note: each undeclared identifier is reported only once for each function it appears in
kern/process/proc.c: In function 'proc_run':
kern/process/proc.c:191:13: warning: implicit declaration of function 'load_esp0' [-Wimplicit-function-declaration]
             load_esp0(proc->kstack + KSTACKSIZE);
             ^~~~~~~~~
kern/process/proc.c:193:13: error: too few arguments to function 'switch_to'
             switch_to(&(current->context)); // Context switching between two processes
             ^~~~~~~~~
kern/process/proc.c:82:6: note: declared here
 void switch_to(struct context *from, struct context *to);
      ^~~~~~~~~
make: *** [Makefile:120: obj/kern/process/proc.o] Error 1



再次更正：
// Exercise 3: proc_run
void
proc_run(struct proc_struct *proc) {
    if (proc != current) {
        bool intr_flag;
        local_intr_save(intr_flag); // Disable interrupts
        {
            struct proc_struct *prev = current, *next = proc; // Define previous and next process
            current = proc;
            // load_esp0(proc->kstack + KSTACKSIZE); // Modify this line according to your environment
            lcr3(PADDR(proc->cr3)); // Modify the value of CR3 register
            switch_to(&(prev->context), &(next->context)); // Context switching between two processes
        }
        local_intr_restore(intr_flag); // Enable Interrupts
    }
}
