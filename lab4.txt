// Exercise 1: alloc_proc
static struct proc_struct *
alloc_proc(void) {
    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
    if (proc != NULL) {
        proc->state = PROC_UNINIT;                      // Process state
        proc->pid = -1;                                 // Process ID
        proc->runs = 0;                                 // The running times of Process
        proc->kstack = 0;                               // Process kernel stack
        proc->need_resched = false;                     // Bool value: need to be rescheduled to release CPU?
        proc->parent = NULL;                            // The parent process
        proc->mm = NULL;                                // Process's memory management field
        memset(&(proc->context), 0, sizeof(struct context)); // Switch here to run process
        proc->tf = NULL;                                // Trap frame for current interrupt
        proc->cr3 = boot_cr3;                           // CR3 register: the base addr of Page Directroy Table(PDT)
        proc->flags = 0;                                // Process flag
        memset(proc->name, 0, PROC_NAME_LEN);           // Process name
    }
    return proc;
}

// Exercise 2: do_fork
int
do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {
    int ret = -E_NO_FREE_PROC;
    struct proc_struct *proc;
    if (nr_process >= MAX_PROCESS) {
        goto fork_out;
    }
    ret = -E_NO_MEM;

    // 1. call alloc_proc to allocate a proc_struct
    proc = alloc_proc();
    if (proc == NULL) {
        goto fork_out;
    }

    // 2. call setup_kstack to allocate a kernel stack for child process
    if (setup_kstack(proc) != 0) {
        goto bad_fork_cleanup_proc;
    }

    // 3. call copy_mm to dup OR share mm according clone_flag
    if (copy_mm(clone_flags, proc) != 0) {
        goto bad_fork_cleanup_kstack;
    }

    // 4. call copy_thread to setup tf & context in proc_struct
    copy_thread(proc, stack, tf);

    // 5. insert proc_struct into hash_list && proc_list
    hash_proc(proc);
    list_add(&proc_list, &(proc->list_link));
    nr_process ++;

    // 6. call wakeup_proc to make the new child process RUNNABLE
    wakeup_proc(proc);

    // 7. set ret value using child proc's pid
    ret = proc->pid;

    goto fork_out;

bad_fork_cleanup_kstack:
    put_kstack(proc);
bad_fork_cleanup_proc:
    kfree(proc);
fork_out:
    return ret;
}

// Exercise 3: proc_run
void
proc_run(struct proc_struct *proc) {
    if (proc != current) {
        bool intr_flag;
        local_intr_save(intr_flag); // Disable interrupts
        {
            current = proc;
            load_esp0(proc->kstack + KSTACKSIZE);
            lcr3(PADDR(proc->cr3)); // Modify the value of CR3 register
            switch_to(&(current->context)); // Context switching between two processes
        }
        local_intr_restore(intr_flag); // Enable Interrupts
    }
}